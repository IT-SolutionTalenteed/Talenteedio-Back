        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        getFreelances: async (_: any, args: { input: PaginationInput; filter: { name: string; status: string } }): Promise<Resource<Freelance>> => {
            try {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                let filters: any;

                if (args.filter) {
                    filters = args.filter.name ? { where: { title: Like(`%${args.filter.name}%`) } } : { where: {} };

                    if (args.filter.status) {
                        filters.where.status = args.filter.status;
                    }
                }

                const res = (await getResources(Freelance, args.input, freelanceRelations, filters)) as Resource<Freelance>;

                return res;

                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            } catch (error: any) {
                throw returnError(error);
            }
        },
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        getOneFreelance: async (_: any, args: { input: { id: string } }, context: any): Promise<Freelance> => {
            try {
                const freelance = await Freelance.findOne({
                    where: {
                        id: args.input.id,
                    },
                    relations: freelanceRelations,
                });

                if (freelance) {
                    const user = context.req.session.user as User;

                    if (user.freelance && freelance.id !== user.freelance.id) {
                        throw createGraphQLError('Access denied for this freelance', { extensions: { statusCode: 403, statusText: FORBIDDEN } });
                    }

                    return freelance;
                }

                throw createGraphQLError('Freelance not found', { extensions: { statusCode: 404, statusText: NOT_FOUND } });

                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            } catch (error: any) {
                throw returnError(error);
            }
        },
